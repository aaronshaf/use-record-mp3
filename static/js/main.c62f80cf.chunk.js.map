{"version":3,"sources":["../../src/convert.ts","../../src/index.ts","../../src/utils.ts","App.tsx","index.tsx"],"names":["outBuffer","Uint8Array","AudioContext","window","stream","useState","recordingLength","useRef","leftChannel","audioContext","encoderOptions","pcm_l","encoderPromise","useMemo","createMp3Encoder","useEffect","encoder","options","sampleRate","channels","bitrate","vbrQuality","offset","moreData","mp3Data","newBuffer","result","mp3Blob","Blob","type","mp3BlobUrl","URL","setBlob","setBlobUrl","blobUrl","useConvert","channelData","isRecording","recorder","mediaStream","data","channelBuffer","Float32Array","i","buffer","flattenArray","setChannelData","isRecordingPaused","startRecording","setIsRecording","setisRecordingPaused","context","e","leftChannelData","setRecorder","mediaStream2","setMediaStream","stopRecording","pauseRecording","blob","App","audio","constraints","useUserMedia","useRecordMp3","chartComponents","rawData","blockSize","Math","floor","length","filteredData","blockStart","sum","j","abs","push","filterData","map","number","index","key","style","width","height","backgroundColor","className","ow","disabled","onClick","controls","src","display","alignItems","color","position","href","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c62f80cf.chunk.js","sourcesContent":["import { useEffect, useState, useMemo } from \"react\";\nimport { createMp3Encoder } from \"wasm-media-encoders\";\nimport { EncoderOptions } from \"./typings\";\n\nlet outBuffer = new Uint8Array(1024 * 1024);\n\nconst useConvert = (pcm_l: any, options: EncoderOptions) => {\n  const [blob, setBlob] = useState<Blob | null>(null);\n  const [blobUrl, setBlobUrl] = useState<string | null>(null);\n  const encoderPromise = useMemo(() => createMp3Encoder(), []);\n\n  useEffect(() => {\n    if (!pcm_l) return;\n    encoderPromise.then((encoder) => {\n      encoder.configure(\n        options.bitrate\n          ? {\n              sampleRate: options.sampleRate || 48000,\n              channels: options.channels || 1,\n              bitrate: options.bitrate,\n            }\n          : {\n              sampleRate: options.sampleRate || 48000,\n              channels: options.channels || 1,\n              vbrQuality: options.vbrQuality || 2,\n            }\n      );\n\n      let offset = 0;\n      let moreData = true;\n\n      while (true) {\n        const mp3Data = moreData\n          ? encoder.encode([\n              pcm_l /* Float32Array of left channel PCM data */,\n              // pcm_r /* Float32Array of right channel PCM data */,\n            ])\n          : /* finalize() returns the last few frames */\n            encoder.finalize();\n\n        /* mp3Data is a Uint8Array that is still owned by the encoder and MUST be copied */\n        if (mp3Data.length + offset > outBuffer.length) {\n          const newBuffer = new Uint8Array(mp3Data.length + offset);\n          newBuffer.set(outBuffer);\n          outBuffer = newBuffer;\n        }\n\n        outBuffer.set(mp3Data, offset);\n        offset += mp3Data.length;\n\n        if (!moreData) {\n          break;\n        }\n\n        moreData = false;\n      }\n\n      const result = new Uint8Array(outBuffer.buffer, 0, offset);\n\n      const mp3Blob = new Blob([new Uint8Array(result).buffer], {\n        type: \"audio/mpeg\",\n      });\n      const mp3BlobUrl = URL.createObjectURL(mp3Blob);\n\n      setBlob(mp3Blob);\n      setBlobUrl(mp3BlobUrl);\n    });\n  }, [pcm_l]);\n\n  return [blobUrl, blob];\n};\n\nexport default useConvert;\n","import { flattenArray } from \"./utils\";\nimport useConvert from \"./convert\";\nimport { useState, useEffect, useRef } from \"react\";\nimport { EncoderOptions } from \"./typings\";\n\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n\nconst bufferSize = 2048;\nconst numberOfInputChannels = 1;\nconst numberOfOutputChannels = 1;\n\nconst useRecordMp3 = (stream: any, encoderOptions: EncoderOptions) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [isRecordingPaused, setisRecordingPaused] = useState(false);\n  const [\n    mediaStream,\n    setMediaStream,\n  ] = useState<MediaStreamAudioSourceNode | null>(null);\n  const [recorder, setRecorder] = useState<ScriptProcessorNode | null>(null);\n  const recordingLength = useRef(0);\n  const leftChannel = useRef<Array<Float32Array>>([]);\n\n  const [channelData, setChannelData] = useState<Float32Array | null>(null);\n  const audioContext = useRef<AudioContext | null>(null);\n\n  // TODO: stop mutating object?\n  if (stream && !encoderOptions.sampleRate) {\n    encoderOptions.sampleRate = stream\n      .getAudioTracks()[0]\n      .getCapabilities().sampleRate.max;\n  }\n\n  const [blobUrl, blob]: any = useConvert(channelData, encoderOptions);\n\n  const startRecording = () => {\n    if (!stream) return;\n\n    setIsRecording(true);\n    if (!isRecordingPaused) {\n      recordingLength.current = 0;\n      leftChannel.current = [];\n    }\n    setisRecordingPaused(false);\n\n    audioContext.current = new AudioContext({\n      sampleRate: encoderOptions.sampleRate,\n    });\n    const context = audioContext.current;\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n    // bufferSize: the onaudioprocess event is called when the buffer is full\n    let recorder: ScriptProcessorNode;\n    if (context.createScriptProcessor) {\n      recorder = context.createScriptProcessor(\n        bufferSize,\n        numberOfInputChannels,\n        numberOfOutputChannels\n      );\n    } else {\n      recorder = (context as any).createJavaScriptNode(\n        bufferSize,\n        numberOfInputChannels,\n        numberOfOutputChannels\n      );\n    }\n\n    recorder.onaudioprocess = function (e: any) {\n      const leftChannelData = new Float32Array(e.inputBuffer.getChannelData(0));\n      leftChannel.current.push(leftChannelData);\n      // rightchannel.push(\n      //   new Float32Array(e.inputBuffer.getChannelData(1))\n      // );\n      recordingLength.current = recordingLength.current + bufferSize;\n    };\n\n    setRecorder(recorder);\n    const mediaStream2 = context.createMediaStreamSource(stream);\n    setMediaStream(mediaStream2);\n    mediaStream2.connect(recorder);\n    recorder.connect(context.destination);\n  };\n\n  const pauseRecording = () => {\n    setIsRecording(false);\n    setisRecordingPaused(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n    setisRecordingPaused(false);\n  };\n\n  useEffect(() => {\n    if (isRecording === false) {\n      if (recorder && mediaStream && audioContext.current) {\n        recorder && recorder.disconnect(audioContext.current.destination);\n        mediaStream && mediaStream.disconnect(recorder);\n        const data = flattenArray(leftChannel.current, recordingLength.current);\n        setChannelData(data);\n      }\n    }\n  }, [isRecording]);\n\n  return {\n    isRecording,\n    isRecordingPaused,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    blobUrl,\n    blob,\n    channelData,\n  };\n};\n\nexport default useRecordMp3;\n","export function flattenArray(channelBuffer: any, recordingLength: number) {\n  var result = new Float32Array(recordingLength);\n  var offset = 0;\n  for (var i = 0; i < channelBuffer.length; i++) {\n    var buffer = channelBuffer[i];\n    result.set(buffer, offset);\n    offset += buffer.length;\n  }\n  return result;\n}\n\nexport function convertToArrayBuffer(blob: Blob) {\n  const url = URL.createObjectURL(blob);\n\n  return fetch(url).then((response) => {\n    return response.arrayBuffer();\n  });\n}\n\n// function process(data) {\n//   const blob = new Blob(data);\n\n//   convertToArrayBuffer(blob)\n//     .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))\n//     .then((audioBuffer) => {\n//       const channelData = audioBuffer.getChannelData(0);\n//       setChannelData(channelData);\n//     });\n// }\n","import React, { useState } from \"react\";\nimport useUserMedia from \"react-use-user-media\";\nimport useRecordMp3 from \"use-record-mp3\";\nimport ow from \"oceanwind\";\nimport GitHubRibbon from \"react-github-fork-ribbon\";\n\n// https://css-tricks.com/making-an-audio-waveform-visualizer-with-vanilla-javascript/\nconst filterData = (rawData: any) => {\n  // const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n  const samples = 1000; // Number of samples we want to have in our final data set\n  const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n  const filteredData = [];\n  for (let i = 0; i < samples; i++) {\n    let blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n  }\n  return filteredData;\n};\n\n// const normalizeData = (filteredData: any) => {\n//   const multiplier = Math.pow(Math.max(...filteredData), -1)\n//   return filteredData.map((n: any) => n * multiplier)\n// }\n\nconst App = () => {\n  const [constraints] = useState({\n    audio: true,\n  });\n  const { stream } = useUserMedia(constraints);\n  const {\n    isRecording,\n    isRecordingPaused,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    blobUrl,\n    channelData,\n  } = useRecordMp3(stream, {\n    // channels: 1,\n    // bitrate: 96,\n    vbrQuality: 2,\n  });\n\n  const chart = channelData ? filterData(channelData) : [];\n  const chartComponents = chart.map((number: number, index: number) => {\n    return (\n      <div\n        key={index}\n        style={{\n          width: \"0.1%\",\n          height: `${number * 100}%`,\n          backgroundColor: \"red\",\n        }}\n      ></div>\n    );\n  });\n  return (\n    <div className={ow`p-6`}>\n      <button\n        disabled={isRecording}\n        className={ow`px-4 mr-1 py-2 border border-black rounded text-lg`}\n        onClick={startRecording}\n      >\n        Record\n      </button>\n      <button\n        disabled={!(isRecording || (!isRecording && isRecordingPaused))}\n        className={ow`px-4 mr-1 py-2 border border-black rounded text-lg`}\n        onClick={stopRecording}\n      >\n        Stop\n      </button>\n      <button\n        disabled={!isRecording && !isRecordingPaused}\n        className={ow`px-4 py-2 border border-black rounded text-lg`}\n        onClick={isRecordingPaused ? startRecording : pauseRecording}\n      >\n        Pause\n      </button>\n      {blobUrl && (\n        <div className={ow`pt-4`}>\n          <audio controls src={blobUrl}></audio>\n          <div\n            style={{\n              display: \"flex\",\n              alignItems: \"center\",\n              width: \"300px\",\n              height: \"100px\",\n            }}\n          >\n            {chartComponents}\n          </div>\n        </div>\n      )}\n\n      <GitHubRibbon\n        color=\"black\"\n        position=\"right\"\n        href=\"https://github.com/aaronshaf/use-record-mp3\"\n      >\n        GitHub repo\n      </GitHubRibbon>\n    </div>\n  );\n};\n\nexport default App;\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}