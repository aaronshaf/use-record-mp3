{"version":3,"sources":["../../src/convert.ts","../../src/index.ts","../../src/utils.ts","App.tsx","index.tsx"],"names":["outBuffer","Uint8Array","AudioContext","window","stream","useState","recordingLength","useRef","leftChannel","audioContext","pcm_l","encoderPromise","useMemo","createMp3Encoder","useEffect","encoder","sampleRate","channels","vbrQuality","offset","moreData","mp3Data","newBuffer","result","mp3Blob","Blob","type","mp3BlobUrl","URL","setBlob","setBlobUrl","blobUrl","useConvert","isRecording","setChannelData","context","recorder","e","leftChannelData","Float32Array","setRecorder","mediaStream2","setMediaStream","mediaStream","data","channelBuffer","i","buffer","flattenArray","setIsRecording","blob","channelData","constraints","audio","App","useUserMedia","useRecordMp3","chartComponents","rawData","blockSize","Math","floor","length","filteredData","blockStart","sum","j","abs","push","filterData","map","number","index","key","style","width","height","backgroundColor","className","ow","onClick","controls","src","display","alignItems","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.cd37c460.chunk.js","sourcesContent":["import { useEffect, useState, useMemo } from \"react\";\nimport { createMp3Encoder } from \"wasm-media-encoders\";\n\nlet outBuffer = new Uint8Array(1024 * 1024);\n\nconst useConvert = (pcm_l: any) => {\n  const [blob, setBlob] = useState<Blob | null>(null);\n  const [blobUrl, setBlobUrl] = useState<string | null>(null);\n  const encoderPromise = useMemo(() => createMp3Encoder(), []);\n\n  useEffect(() => {\n    if (!pcm_l) return;\n    encoderPromise.then((encoder) => {\n      encoder.configure({\n        sampleRate: 48000,\n        channels: 1,\n        vbrQuality: 1,\n      });\n\n      let offset = 0;\n      let moreData = true;\n\n      while (true) {\n        const mp3Data = moreData\n          ? encoder.encode([\n              pcm_l /* Float32Array of left channel PCM data */,\n              // pcm_r /* Float32Array of right channel PCM data */,\n            ])\n          : /* finalize() returns the last few frames */\n            encoder.finalize();\n\n        /* mp3Data is a Uint8Array that is still owned by the encoder and MUST be copied */\n        if (mp3Data.length + offset > outBuffer.length) {\n          const newBuffer = new Uint8Array(mp3Data.length + offset);\n          newBuffer.set(outBuffer);\n          outBuffer = newBuffer;\n        }\n\n        outBuffer.set(mp3Data, offset);\n        offset += mp3Data.length;\n\n        if (!moreData) {\n          break;\n        }\n\n        moreData = false;\n      }\n\n      const result = new Uint8Array(outBuffer.buffer, 0, offset);\n\n      const mp3Blob = new Blob([new Uint8Array(result).buffer], {\n        type: \"audio/mpeg\",\n      });\n      const mp3BlobUrl = URL.createObjectURL(mp3Blob);\n\n      setBlob(mp3Blob);\n      setBlobUrl(mp3BlobUrl);\n    });\n  }, [pcm_l]);\n\n  return [blobUrl, blob];\n};\n\nexport default useConvert;\n","import { flattenArray } from \"./utils\";\nimport useConvert from \"./convert\";\nimport { useState, useEffect, useRef } from \"react\";\n\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n\nconst bufferSize = 2048;\nconst numberOfInputChannels = 1;\nconst numberOfOutputChannels = 1;\n\nconst useRecordMp3 = (stream: any) => {\n  const [isRecording, setIsRecording] = useState(false);\n\n  const [\n    mediaStream,\n    setMediaStream,\n  ] = useState<MediaStreamAudioSourceNode | null>(null);\n  const [recorder, setRecorder] = useState<ScriptProcessorNode | null>(null);\n  const recordingLength = useRef(0);\n  const leftChannel = useRef<Array<Float32Array>>([]);\n\n  const [channelData, setChannelData] = useState<Float32Array | null>(null);\n  const audioContext = useRef<AudioContext | null>(null);\n  const [blobUrl, blob]: any = useConvert(channelData);\n\n  useEffect(() => {\n    if (isRecording && stream) {\n      setChannelData(null);\n\n      audioContext.current = new AudioContext();\n      const context = audioContext.current;\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n      // bufferSize: the onaudioprocess event is called when the buffer is full\n      let recorder: ScriptProcessorNode;\n      if (context.createScriptProcessor) {\n        recorder = context.createScriptProcessor(\n          bufferSize,\n          numberOfInputChannels,\n          numberOfOutputChannels\n        );\n      } else {\n        recorder = (context as any).createJavaScriptNode(\n          bufferSize,\n          numberOfInputChannels,\n          numberOfOutputChannels\n        );\n      }\n\n      recorder.onaudioprocess = function (e: any) {\n        const leftChannelData = new Float32Array(\n          e.inputBuffer.getChannelData(0)\n        );\n        leftChannel.current.push(leftChannelData);\n        // rightchannel.push(\n        //   new Float32Array(e.inputBuffer.getChannelData(1))\n        // );\n        recordingLength.current = recordingLength.current + bufferSize;\n      };\n\n      setRecorder(recorder);\n      const mediaStream2 = context.createMediaStreamSource(stream);\n      setMediaStream(mediaStream2);\n      mediaStream2.connect(recorder);\n      recorder.connect(context.destination);\n    } else if (isRecording === false) {\n      if (recorder && mediaStream && audioContext.current) {\n        recorder && recorder.disconnect(audioContext.current.destination);\n        mediaStream && mediaStream.disconnect(recorder);\n        const data = flattenArray(leftChannel.current, recordingLength.current);\n        setChannelData(data);\n      }\n    }\n  }, [isRecording]);\n\n  return { isRecording, setIsRecording, blobUrl, blob, channelData };\n};\n\nexport default useRecordMp3;\n","export function flattenArray(channelBuffer: any, recordingLength: number) {\n  var result = new Float32Array(recordingLength);\n  var offset = 0;\n  for (var i = 0; i < channelBuffer.length; i++) {\n    var buffer = channelBuffer[i];\n    result.set(buffer, offset);\n    offset += buffer.length;\n  }\n  return result;\n}\n\nexport function convertToArrayBuffer(blob: Blob) {\n  const url = URL.createObjectURL(blob);\n\n  return fetch(url).then((response) => {\n    return response.arrayBuffer();\n  });\n}\n\n// function process(data) {\n//   const blob = new Blob(data);\n\n//   convertToArrayBuffer(blob)\n//     .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))\n//     .then((audioBuffer) => {\n//       const channelData = audioBuffer.getChannelData(0);\n//       setChannelData(channelData);\n//     });\n// }\n","import React from \"react\";\nimport useUserMedia from \"react-use-user-media\";\nimport useRecordMp3 from \"use-record-mp3\";\nimport ow from \"oceanwind\";\n\nconst constraints = {\n  // audio: true\n  audio: {\n    //   // sampleRate: 48000,\n    //   // sampleSize: 16,\n    // channelCount: 2,\n  },\n};\n\n// https://css-tricks.com/making-an-audio-waveform-visualizer-with-vanilla-javascript/\nconst filterData = (rawData: any) => {\n  // const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n  const samples = 1000; // Number of samples we want to have in our final data set\n  const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n  const filteredData = [];\n  for (let i = 0; i < samples; i++) {\n    let blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n  }\n  return filteredData;\n};\n\n// const normalizeData = (filteredData: any) => {\n//   const multiplier = Math.pow(Math.max(...filteredData), -1)\n//   return filteredData.map((n: any) => n * multiplier)\n// }\n\nconst App = () => {\n  const { stream } = useUserMedia(constraints);\n  const { isRecording, setIsRecording, blobUrl, channelData } = useRecordMp3(\n    stream\n  );\n\n  const chart = channelData ? filterData(channelData) : [];\n  const chartComponents = chart.map((number: number, index: number) => {\n    return (\n      <div\n        key={index}\n        style={{\n          width: \"0.1%\",\n          height: `${number * 100}%`,\n          backgroundColor: \"red\",\n        }}\n      ></div>\n    );\n  });\n  return (\n    <div className={ow`p-6`}>\n      <button\n        className={ow`px-4 py-2 border border-black rounded text-lg`}\n        onClick={() => setIsRecording(!isRecording)}\n      >\n        {isRecording ? \"Stop\" : \"Record\"}\n      </button>\n      {blobUrl && (\n        <div className={ow`pt-4`}>\n          <audio controls src={blobUrl}></audio>\n          <div\n            style={{\n              display: \"flex\",\n              alignItems: \"center\",\n              width: \"300px\",\n              height: \"100px\",\n            }}\n          >\n            {chartComponents}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default App;\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}