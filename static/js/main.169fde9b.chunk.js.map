{"version":3,"sources":["../../src/convert.ts","../../src/index.ts","../../src/utils.ts","App.tsx","index.tsx"],"names":["outBuffer","Uint8Array","AudioContext","window","stream","useState","recordingLength","useRef","leftChannel","audioContext","encoderOptions","pcm_l","encoderPromise","useMemo","createMp3Encoder","useEffect","encoder","options","sampleRate","channels","bitrate","vbrQuality","offset","moreData","mp3Data","newBuffer","result","mp3Blob","Blob","type","mp3BlobUrl","URL","setBlob","setBlobUrl","blobUrl","useConvert","channelData","average","array","total","sum","isRecording","recorder","mediaStream","trimmedData","data","rollingAverageArray","index","Math","trimEndingSilence","trimBeginningSilence","channelBuffer","Float32Array","i","buffer","flattenArray","setChannelData","isRecordingPaused","startRecording","setIsRecording","setisRecordingPaused","context","e","leftChannelData","setRecorder","mediaStream2","setMediaStream","stopRecording","pauseRecording","blob","App","audio","constraints","useUserMedia","device","getAudioTracks","label","useRecordMp3","chartComponents","rawData","blockSize","floor","length","filteredData","blockStart","j","abs","push","filterData","map","number","key","style","width","height","backgroundColor","className","ow","disabled","onClick","controls","src","display","alignItems","color","position","href","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.169fde9b.chunk.js","sourcesContent":["import { useEffect, useState, useMemo } from \"react\";\nimport { createMp3Encoder } from \"wasm-media-encoders\";\nimport { EncoderOptions } from \"./typings\";\n\nlet outBuffer = new Uint8Array(1024 * 1024);\n\nconst useConvert = (pcm_l: any, options: EncoderOptions) => {\n  const [blob, setBlob] = useState<Blob | null>(null);\n  const [blobUrl, setBlobUrl] = useState<string | null>(null);\n  const encoderPromise = useMemo(() => createMp3Encoder(), []);\n\n  useEffect(() => {\n    if (!pcm_l) return;\n    encoderPromise.then((encoder) => {\n      encoder.configure(\n        options.bitrate\n          ? {\n              sampleRate: options.sampleRate || 48000,\n              channels: options.channels || 1,\n              bitrate: options.bitrate,\n            }\n          : {\n              sampleRate: options.sampleRate || 48000,\n              channels: options.channels || 1,\n              vbrQuality: options.vbrQuality || 2,\n            }\n      );\n\n      let offset = 0;\n      let moreData = true;\n\n      while (true) {\n        const mp3Data = moreData\n          ? encoder.encode([\n              pcm_l /* Float32Array of left channel PCM data */,\n              // pcm_r /* Float32Array of right channel PCM data */,\n            ])\n          : /* finalize() returns the last few frames */\n            encoder.finalize();\n\n        /* mp3Data is a Uint8Array that is still owned by the encoder and MUST be copied */\n        if (mp3Data.length + offset > outBuffer.length) {\n          const newBuffer = new Uint8Array(mp3Data.length + offset);\n          newBuffer.set(outBuffer);\n          outBuffer = newBuffer;\n        }\n\n        outBuffer.set(mp3Data, offset);\n        offset += mp3Data.length;\n\n        if (!moreData) {\n          break;\n        }\n\n        moreData = false;\n      }\n\n      const result = new Uint8Array(outBuffer.buffer, 0, offset);\n\n      const mp3Blob = new Blob([new Uint8Array(result).buffer], {\n        type: \"audio/mpeg\",\n      });\n      const mp3BlobUrl = URL.createObjectURL(mp3Blob);\n\n      setBlob(mp3Blob);\n      setBlobUrl(mp3BlobUrl);\n    });\n  }, [pcm_l]);\n\n  return [blobUrl, blob];\n};\n\nexport default useConvert;\n","import { flattenArray } from \"./utils\";\nimport useConvert from \"./convert\";\nimport { useState, useEffect, useRef } from \"react\";\nimport { EncoderOptions } from \"./typings\";\n\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n\nconst bufferSize = 2048;\nconst numberOfInputChannels = 1;\nconst numberOfOutputChannels = 1;\n\nconst useRecordMp3 = (stream: any, encoderOptions: EncoderOptions) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [isRecordingPaused, setisRecordingPaused] = useState(false);\n  const [\n    mediaStream,\n    setMediaStream,\n  ] = useState<MediaStreamAudioSourceNode | null>(null);\n  const [recorder, setRecorder] = useState<ScriptProcessorNode | null>(null);\n  const recordingLength = useRef(0);\n  const leftChannel = useRef<Array<Float32Array>>([]);\n\n  const [channelData, setChannelData] = useState<Float32Array | null>(null);\n  const audioContext = useRef<AudioContext | null>(null);\n\n  // TODO: stop mutating object?\n  if (stream && !encoderOptions.sampleRate) {\n    encoderOptions.sampleRate = stream\n      .getAudioTracks()[0]\n      .getCapabilities().sampleRate.max;\n  }\n\n  const [blobUrl, blob]: any = useConvert(channelData, encoderOptions);\n\n  const startRecording = () => {\n    if (!stream) return;\n\n    setIsRecording(true);\n    if (!isRecordingPaused) {\n      recordingLength.current = 0;\n      leftChannel.current = [];\n    }\n    setisRecordingPaused(false);\n\n    audioContext.current = new AudioContext({\n      sampleRate: encoderOptions.sampleRate,\n    });\n    const context = audioContext.current;\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n    // bufferSize: the onaudioprocess event is called when the buffer is full\n    let recorder: ScriptProcessorNode;\n    if (context.createScriptProcessor) {\n      recorder = context.createScriptProcessor(\n        bufferSize,\n        numberOfInputChannels,\n        numberOfOutputChannels\n      );\n    } else {\n      recorder = (context as any).createJavaScriptNode(\n        bufferSize,\n        numberOfInputChannels,\n        numberOfOutputChannels\n      );\n    }\n\n    recorder.onaudioprocess = function (e: any) {\n      const leftChannelData = new Float32Array(e.inputBuffer.getChannelData(0));\n      leftChannel.current.push(leftChannelData);\n      // rightchannel.push(\n      //   new Float32Array(e.inputBuffer.getChannelData(1))\n      // );\n      recordingLength.current = recordingLength.current + bufferSize;\n    };\n\n    setRecorder(recorder);\n    const mediaStream2 = context.createMediaStreamSource(stream);\n    setMediaStream(mediaStream2);\n    mediaStream2.connect(recorder);\n    recorder.connect(context.destination);\n  };\n\n  const pauseRecording = () => {\n    setIsRecording(false);\n    setisRecordingPaused(true);\n  };\n\n  const stopRecording = () => {\n    setIsRecording(false);\n    setisRecordingPaused(false);\n  };\n\n  const sum = (array: Array<number>) =>\n    array.reduce((total, value) => total + value, 0);\n  const average = (array: Array<number>) => sum(array) / array.length;\n\n  const TRIM_SIZE = 5000;\n  const ROLLING_AVERAGE_SIZE = 50;\n\n  // fruits.shift() take from front\n  // fruits.push()\n\n  const trimBeginningSilence = (data: Float32Array) => {\n    const TRIM_THRESHOLD = 0.02;\n    const rollingAverageArray = [];\n    for (let index = 0; index < data.length; index++) {\n      rollingAverageArray.push(Math.abs(data[index]));\n      if (rollingAverageArray.length > ROLLING_AVERAGE_SIZE) {\n        rollingAverageArray.shift();\n      }\n      if (average(rollingAverageArray) > TRIM_THRESHOLD) {\n        return data.slice(index > TRIM_SIZE ? index - TRIM_SIZE : 0);\n      }\n    }\n    return data;\n  };\n\n  const trimEndingSilence = (data: Float32Array) => {\n    const TRIM_THRESHOLD = 0.0075;\n    const rollingAverageArray = [];\n    for (let index = data.length; index > 0; index--) {\n      rollingAverageArray.push(Math.abs(data[index]));\n      if (rollingAverageArray.length > ROLLING_AVERAGE_SIZE) {\n        rollingAverageArray.shift();\n      }\n\n      if (average(rollingAverageArray) > TRIM_THRESHOLD) {\n        return data.slice(\n          0,\n          index < data.length - TRIM_SIZE ? index + TRIM_SIZE : data.length\n        );\n      }\n    }\n    return data;\n  };\n\n  useEffect(() => {\n    if (isRecording === false) {\n      if (recorder && mediaStream && audioContext.current) {\n        recorder && recorder.disconnect(audioContext.current.destination);\n        mediaStream && mediaStream.disconnect(recorder);\n        const data = flattenArray(leftChannel.current, recordingLength.current);\n        const trimmedData = trimEndingSilence(trimBeginningSilence(data));\n        setChannelData(trimmedData);\n      }\n    }\n  }, [isRecording]);\n\n  return {\n    isRecording,\n    isRecordingPaused,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    blobUrl,\n    blob,\n    channelData,\n  };\n};\n\nexport default useRecordMp3;\n","export function flattenArray(channelBuffer: any, recordingLength: number) {\n  var result = new Float32Array(recordingLength);\n  var offset = 0;\n  for (var i = 0; i < channelBuffer.length; i++) {\n    var buffer = channelBuffer[i];\n    result.set(buffer, offset);\n    offset += buffer.length;\n  }\n  return result;\n}\n\nexport function convertToArrayBuffer(blob: Blob) {\n  const url = URL.createObjectURL(blob);\n\n  return fetch(url).then((response) => {\n    return response.arrayBuffer();\n  });\n}\n\n// function process(data) {\n//   const blob = new Blob(data);\n\n//   convertToArrayBuffer(blob)\n//     .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))\n//     .then((audioBuffer) => {\n//       const channelData = audioBuffer.getChannelData(0);\n//       setChannelData(channelData);\n//     });\n// }\n","import React, { useState } from \"react\";\nimport useUserMedia from \"react-use-user-media\";\nimport useRecordMp3 from \"use-record-mp3\";\nimport ow from \"oceanwind\";\nimport GitHubRibbon from \"react-github-fork-ribbon\";\n\n// https://css-tricks.com/making-an-audio-waveform-visualizer-with-vanilla-javascript/\nconst filterData = (rawData: any) => {\n  // const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n  const samples = 1000; // Number of samples we want to have in our final data set\n  const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n  const filteredData = [];\n  for (let i = 0; i < samples; i++) {\n    let blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n  }\n  return filteredData;\n};\n\n// const normalizeData = (filteredData: any) => {\n//   const multiplier = Math.pow(Math.max(...filteredData), -1)\n//   return filteredData.map((n: any) => n * multiplier)\n// }\n\nconst App = () => {\n  const [constraints] = useState<MediaStreamConstraints>({\n    audio: true,\n  });\n  const { stream } = useUserMedia(constraints);\n\n  const device = stream && stream.getAudioTracks()[0].label;\n\n  const {\n    isRecording,\n    isRecordingPaused,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    blobUrl,\n    channelData,\n  } = useRecordMp3(stream, {\n    sampleRate: 48000,\n    channels: 1,\n    // bitrate: 96,\n    vbrQuality: 2,\n  });\n\n  // console.debug({ channelData });\n\n  const chart = channelData ? filterData(channelData) : [];\n  const chartComponents = chart.map((number: number, index: number) => {\n    return (\n      <div\n        key={index}\n        style={{\n          width: \"0.1%\",\n          height: `${number * 100}%`,\n          backgroundColor: \"red\",\n        }}\n      ></div>\n    );\n  });\n\n  return (\n    <div className={ow`p-6`}>\n      <button\n        disabled={isRecording}\n        className={ow`px-4 mr-1 py-2 border border-black rounded text-lg`}\n        onClick={startRecording}\n      >\n        Record\n      </button>\n      <button\n        disabled={!(isRecording || (!isRecording && isRecordingPaused))}\n        className={ow`px-4 mr-1 py-2 border border-black rounded text-lg`}\n        onClick={stopRecording}\n      >\n        Stop\n      </button>\n      <button\n        disabled={!isRecording && !isRecordingPaused}\n        className={ow`px-4 py-2 border border-black rounded text-lg`}\n        onClick={isRecordingPaused ? startRecording : pauseRecording}\n      >\n        Pause\n      </button>\n      {blobUrl && (\n        <div className={ow`pt-4`}>\n          <audio controls src={blobUrl}></audio>\n          <div\n            style={{\n              display: \"flex\",\n              alignItems: \"center\",\n              width: \"300px\",\n              height: \"100px\",\n            }}\n          >\n            {chartComponents}\n          </div>\n        </div>\n      )}\n\n      {device}\n\n      <GitHubRibbon\n        color=\"black\"\n        position=\"right\"\n        href=\"https://github.com/aaronshaf/use-record-mp3\"\n      >\n        GitHub repo\n      </GitHubRibbon>\n    </div>\n  );\n};\n\nexport default App;\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}